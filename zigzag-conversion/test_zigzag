jobexecutor

import pytest
from unittest.mock import Mock
from datetime import datetime


class TestJobExecutor:
    """Concise unit tests for JobExecutor using monkeypatch"""
    
    def test_execute_job_success(self, monkeypatch):
        """Test successful job execution - happy path"""
        # Setup mocks
        mock_db = Mock()
        mock_job = Mock()
        mock_job.id = 123
        mock_job.jobname = "test_job" 
        mock_job.user_id = 456
        mock_job.code = "print('hello')"
        mock_job.execution_endpoint_url = "http://test.com"
        
        mock_job_status = Mock()
        mock_response = Mock()
        mock_response.status = "completed"
        mock_response.output = "success"
        mock_response.error = ""
        
        # Monkeypatch all dependencies
        monkeypatch.setattr('job_scheduler.database.SessionLocal', lambda: mock_db)
        monkeypatch.setattr('job_scheduler.models.job_status.JobStatus', lambda **kwargs: mock_job_status)
        monkeypatch.setattr('job_scheduler.services.job_service.JobService.send_script_to_jobservice', 
                          lambda code, url: mock_response)
        monkeypatch.setattr('logging.getLogger', lambda name: Mock())
        
        mock_db.query.return_value.filter.return_value.first.return_value = mock_job
        
        # Import and execute after patching
        from your_module import JobExecutor  # Replace with actual import
        JobExecutor.execute_job(123)
        
        # Assertions
        mock_db.query.assert_called_once()
        mock_db.add.assert_called_with(mock_job_status)
        assert mock_db.commit.call_count == 2
        mock_db.close.assert_called_once()
        assert mock_job_status.status == "completed"
        assert mock_job_status.execution_log == "success "

    def test_execute_job_not_found(self, monkeypatch):
        """Test job not found scenario"""
        mock_db = Mock()
        mock_logger = Mock()
        
        monkeypatch.setattr('job_scheduler.database.SessionLocal', lambda: mock_db)
        monkeypatch.setattr('logging.getLogger', lambda name: mock_logger)
        
        mock_db.query.return_value.filter.return_value.first.return_value = None
        
        from your_module import JobExecutor
        JobExecutor.execute_job(999)
        
        mock_logger.error.assert_called_once_with("Job with ID 999 not found in the database.")
        mock_db.add.assert_not_called()
        mock_db.close.assert_called_once()

    def test_execute_job_service_exception(self, monkeypatch):
        """Test JobService exception handling"""
        mock_db = Mock()
        mock_job = Mock()
        mock_job.id = 123
        mock_job.jobname = "test_job"
        mock_job.user_id = 456
        mock_job_status = Mock()
        mock_logger = Mock()
        
        def mock_service_call(code, url):
            raise Exception("Service down")
        
        monkeypatch.setattr('job_scheduler.database.SessionLocal', lambda: mock_db)
        monkeypatch.setattr('job_scheduler.models.job_status.JobStatus', lambda **kwargs: mock_job_status)
        monkeypatch.setattr('job_scheduler.services.job_service.JobService.send_script_to_jobservice', 
                          mock_service_call)
        monkeypatch.setattr('logging.getLogger', lambda name: mock_logger)
        
        mock_db.query.return_value.filter.return_value.first.return_value = mock_job
        
        from your_module import JobExecutor
        JobExecutor.execute_job(123)
        
        assert mock_job_status.status == "failed"
        assert "Error during job execution: Service down" in mock_job_status.execution_log
        mock_logger.error.assert_called_with("Error during job execution for job 123: Service down")
        mock_db.close.assert_called_once()

    def test_execute_job_database_exception(self, monkeypatch):
        """Test database operation exception"""
        mock_db = Mock()
        mock_logger = Mock()
        
        monkeypatch.setattr('job_scheduler.database.SessionLocal', lambda: mock_db)
        monkeypatch.setattr('logging.getLogger', lambda name: mock_logger)
        
        mock_db.query.side_effect = Exception("DB connection failed")
        
        from your_module import JobExecutor
        JobExecutor.execute_job(123)
        
        mock_logger.error.assert_called_with("An unexpected error occurred during job execution: DB connection failed")
        mock_db.close.assert_called_once()

    def test_execute_job_always_closes_db(self, monkeypatch):
        """Test that db.close() is always called even with exceptions"""
        mock_db = Mock()
        
        monkeypatch.setattr('job_scheduler.database.SessionLocal', lambda: mock_db)
        monkeypatch.setattr('logging.getLogger', lambda name: Mock())
        
        # Make query raise exception
        mock_db.query.side_effect = Exception("Any error")
        
        from your_module import JobExecutor
        JobExecutor.execute_job(123)
        
        # Ensure db.close() was called despite exception
        mock_db.close.assert_called_once()

job scheduler tests :

import pytest
from unittest.mock import Mock, MagicMock, patch
from datetime import datetime, timedelta
import logging

# Assuming imports - adjust paths as needed for your project structure
from job_scheduler.scheduler import JobScheduler
from job_scheduler.models.job import Job


class TestJobScheduler:
    
    def setup_method(self):
        """Reset scheduler before each test"""
        JobScheduler.scheduler = None
    
    def test_initialize_scheduler_success(self, monkeypatch):
        """Test successful scheduler initialization"""
        # Mock dependencies
        mock_get_database_url = Mock(return_value="sqlite:///test.db")
        mock_engine = Mock()
        mock_sqlalchemy_jobstore = Mock()
        mock_background_scheduler = Mock()
        
        monkeypatch.setattr("job_scheduler.scheduler.get_database_url", mock_get_database_url)
        monkeypatch.setattr("job_scheduler.scheduler.engine", mock_engine)
        monkeypatch.setattr("job_scheduler.scheduler.SQLAlchemyJobStore", mock_sqlalchemy_jobstore)
        monkeypatch.setattr("job_scheduler.scheduler.BackgroundScheduler", mock_background_scheduler)
        
        # Execute
        JobScheduler.initialize_scheduler()
        
        # Assertions
        mock_get_database_url.assert_called_once()
        mock_sqlalchemy_jobstore.assert_called_once_with(url="sqlite:///test.db", engine=mock_engine)
        mock_background_scheduler.assert_called_once()
        assert JobScheduler.scheduler is not None
    
    def test_initialize_scheduler_already_initialized(self, monkeypatch):
        """Test that scheduler is not re-initialized if already exists"""
        # Setup existing scheduler
        existing_scheduler = Mock()
        JobScheduler.scheduler = existing_scheduler
        
        mock_background_scheduler = Mock()
        monkeypatch.setattr("job_scheduler.scheduler.BackgroundScheduler", mock_background_scheduler)
        
        # Execute
        JobScheduler.initialize_scheduler()
        
        # Assertions
        assert JobScheduler.scheduler == existing_scheduler
        mock_background_scheduler.assert_not_called()
    
    def test_start_scheduler_success(self, monkeypatch):
        """Test successful scheduler start"""
        # Setup
        mock_scheduler = Mock()
        JobScheduler.scheduler = mock_scheduler
        mock_logging_info = Mock()
        
        monkeypatch.setattr("job_scheduler.scheduler.logging.info", mock_logging_info)
        
        # Execute
        JobScheduler.start_scheduler()
        
        # Assertions
        mock_scheduler.start.assert_called_once()
        mock_logging_info.assert_called_once_with("APScheduler started.")
    
    def test_start_scheduler_no_scheduler(self, monkeypatch):
        """Test start_scheduler when scheduler is None"""
        # Setup
        JobScheduler.scheduler = None
        mock_logging_info = Mock()
        monkeypatch.setattr("job_scheduler.scheduler.logging.info", mock_logging_info)
        
        # Execute
        JobScheduler.start_scheduler()
        
        # Assertions
        mock_logging_info.assert_not_called()
    
    def test_shutdown_scheduler_success(self, monkeypatch):
        """Test successful scheduler shutdown"""
        # Setup
        mock_scheduler = Mock()
        JobScheduler.scheduler = mock_scheduler
        mock_logging_info = Mock()
        
        monkeypatch.setattr("job_scheduler.scheduler.logging.info", mock_logging_info)
        
        # Execute
        JobScheduler.shutdown_scheduler()
        
        # Assertions
        mock_scheduler.shutdown.assert_called_once_with(wait=True)
        mock_logging_info.assert_called_once_with("APScheduler shut down.")
    
    def test_shutdown_scheduler_no_scheduler(self, monkeypatch):
        """Test shutdown_scheduler when scheduler is None"""
        # Setup
        JobScheduler.scheduler = None
        mock_logging_info = Mock()
        monkeypatch.setattr("job_scheduler.scheduler.logging.info", mock_logging_info)
        
        # Execute
        JobScheduler.shutdown_scheduler()
        
        # Assertions
        mock_logging_info.assert_not_called()
    
    def test_add_job_success(self, monkeypatch):
        """Test successful job addition"""
        # Setup mocks
        mock_scheduler = Mock()
        JobScheduler.scheduler = mock_scheduler
        
        mock_cron_trigger = Mock()
        mock_job_executor = Mock()
        mock_logging_info = Mock()
        mock_timedelta = Mock(return_value=timedelta(days=1))
        
        monkeypatch.setattr("job_scheduler.scheduler.CronTrigger", mock_cron_trigger)
        monkeypatch.setattr("job_scheduler.scheduler.JobExecutor", mock_job_executor)
        monkeypatch.setattr("job_scheduler.scheduler.logging.info", mock_logging_info)
        monkeypatch.setattr("job_scheduler.scheduler.timedelta", mock_timedelta)
        
        # Create mock job
        mock_job = Mock()
        mock_job.id = 123
        mock_job.frequency = ['Monday', 'Tuesday', 'Wednesday']
        mock_job.schedule_time = Mock()
        mock_job.schedule_time.hour = 10
        mock_job.schedule_time.minute = 30
        mock_job.start_date = datetime(2024, 1, 1)
        mock_job.end_date = datetime(2024, 12, 31)
        
        # Execute
        JobScheduler.add_job(mock_job)
        
        # Assertions
        expected_days = "mon,tue,wed"
        mock_cron_trigger.assert_called_once_with(
            day_of_week=expected_days,
            hour=10,
            minute=30,
            start_date=datetime(2024, 1, 1),
            end_date=datetime(2024, 12, 31) + timedelta(days=1),
            timezone='US/Eastern'
        )
        
        mock_scheduler.add_job.assert_called_once_with(
            mock_job_executor.execute_job,
            trigger=mock_cron_trigger.return_value,
            args=[123],
            id='123',
            replace_existing=True
        )
        
        mock_logging_info.assert_called_once_with("Job 123 scheduled successfully.")
    
    def test_add_job_scheduler_not_initialized(self):
        """Test add_job raises RuntimeError when scheduler not initialized"""
        # Setup
        JobScheduler.scheduler = None
        mock_job = Mock()
        
        # Execute & Assert
        with pytest.raises(RuntimeError, match="Scheduler is not initialized. Call initialize_scheduler first."):
            JobScheduler.add_job(mock_job)
    
    def test_add_job_same_start_end_date(self, monkeypatch):
        """Test add_job when start_date equals end_date"""
        # Setup mocks
        mock_scheduler = Mock()
        JobScheduler.scheduler = mock_scheduler
        
        mock_cron_trigger = Mock()
        mock_job_executor = Mock()
        mock_logging_info = Mock()
        mock_timedelta = Mock(return_value=timedelta(days=1))
        
        monkeypatch.setattr("job_scheduler.scheduler.CronTrigger", mock_cron_trigger)
        monkeypatch.setattr("job_scheduler.scheduler.JobExecutor", mock_job_executor)
        monkeypatch.setattr("job_scheduler.scheduler.logging.info", mock_logging_info)
        monkeypatch.setattr("job_scheduler.scheduler.timedelta", mock_timedelta)
        
        # Create mock job with same start and end date
        mock_job = Mock()
        mock_job.id = 456
        mock_job.frequency = ['Friday']
        mock_job.schedule_time = Mock()
        mock_job.schedule_time.hour = 14
        mock_job.schedule_time.minute = 0
        same_date = datetime(2024, 6, 1)
        mock_job.start_date = same_date
        mock_job.end_date = same_date
        
        # Execute
        JobScheduler.add_job(mock_job)
        
        # Assertions - should add 1 day to end_date when start_date == end_date
        mock_cron_trigger.assert_called_once_with(
            day_of_week="fri",
            hour=14,
            minute=0,
            start_date=same_date,
            end_date=same_date + timedelta(days=1),
            timezone='US/Eastern'
        )
    
    def test_add_job_exception_during_scheduling(self, monkeypatch):
        """Test add_job handles exceptions during job scheduling"""
        # Setup mocks
        mock_scheduler = Mock()
        mock_scheduler.add_job.side_effect = Exception("Scheduling failed")
        JobScheduler.scheduler = mock_scheduler
        
        mock_cron_trigger = Mock()
        mock_job_executor = Mock()
        mock_timedelta = Mock(return_value=timedelta(days=1))
        
        monkeypatch.setattr("job_scheduler.scheduler.CronTrigger", mock_cron_trigger)
        monkeypatch.setattr("job_scheduler.scheduler.JobExecutor", mock_job_executor)
        monkeypatch.setattr("job_scheduler.scheduler.timedelta", mock_timedelta)
        
        mock_job = Mock()
        mock_job.id = 789
        mock_job.frequency = ['Sunday']
        mock_job.schedule_time = Mock()
        mock_job.schedule_time.hour = 9
        mock_job.schedule_time.minute = 15
        mock_job.start_date = datetime(2024, 1, 1)
        mock_job.end_date = datetime(2024, 1, 2)
        
        # Execute & Assert
        with pytest.raises(Exception, match="Scheduling failed"):
            JobScheduler.add_job(mock_job)
    
    def test_remove_job_success(self, monkeypatch):
        """Test successful job removal"""
        # Setup
        mock_scheduler = Mock()
        JobScheduler.scheduler = mock_scheduler
        mock_logging_info = Mock()
        
        monkeypatch.setattr("job_scheduler.scheduler.logging.info", mock_logging_info)
        
        # Execute
        JobScheduler.remove_job("test_job_id")
        
        # Assertions
        mock_scheduler.remove_job.assert_called_once_with("test_job_id")
        mock_logging_info.assert_called_once_with("Job test_job_id removed.")
    
    def test_remove_job_scheduler_not_initialized(self):
        """Test remove_job raises RuntimeError when scheduler not initialized"""
        # Setup
        JobScheduler.scheduler = None
        
        # Execute & Assert
        with pytest.raises(RuntimeError, match="Scheduler is not initialized."):
            JobScheduler.remove_job("test_job_id")
    
    def test_remove_job_exception_handling(self, monkeypatch):
        """Test remove_job handles exceptions properly"""
        # Setup
        mock_scheduler = Mock()
        mock_scheduler.remove_job.side_effect = Exception("Job not found")
        JobScheduler.scheduler = mock_scheduler
        
        mock_logging_error = Mock()
        monkeypatch.setattr("job_scheduler.scheduler.logging.error", mock_logging_error)
        
        # Execute
        JobScheduler.remove_job("nonexistent_job")
        
        # Assertions
        mock_scheduler.remove_job.assert_called_once_with("nonexistent_job")
        mock_logging_error.assert_called_once_with("Error removing job nonexistent_job: Job not found")
    
    def test_get_jobs_success(self):
        """Test successful job retrieval"""
        # Setup
        mock_jobs = [Mock(), Mock(), Mock()]
        mock_scheduler = Mock()
        mock_scheduler.get_jobs.return_value = mock_jobs
        JobScheduler.scheduler = mock_scheduler
        
        # Execute
        result = JobScheduler.get_jobs()
        
        # Assertions
        assert result == mock_jobs
        mock_scheduler.get_jobs.assert_called_once()
    
    def test_get_jobs_scheduler_not_initialized(self):
        """Test get_jobs raises RuntimeError when scheduler not initialized"""
        # Setup
        JobScheduler.scheduler = None
        
        # Execute & Assert
        with pytest.raises(RuntimeError, match="Scheduler is not initialized."):
            JobScheduler.get_jobs()
    
    def test_get_jobs_empty_list(self):
        """Test get_jobs returns empty list when no jobs scheduled"""
        # Setup
        mock_scheduler = Mock()
        mock_scheduler.get_jobs.return_value = []
        JobScheduler.scheduler = mock_scheduler
        
        # Execute
        result = JobScheduler.get_jobs()
        
        # Assertions
        assert result == []
        mock_scheduler.get_jobs.assert_called_once()
    
    def test_frequency_formatting_edge_cases(self, monkeypatch):
        """Test frequency formatting with various day name formats"""
        # Setup mocks
        mock_scheduler = Mock()
        JobScheduler.scheduler = mock_scheduler
        
        mock_cron_trigger = Mock()
        mock_job_executor = Mock()
        mock_logging_info = Mock()
        mock_timedelta = Mock(return_value=timedelta(days=1))
        
        monkeypatch.setattr("job_scheduler.scheduler.CronTrigger", mock_cron_trigger)
        monkeypatch.setattr("job_scheduler.scheduler.JobExecutor", mock_job_executor)
        monkeypatch.setattr("job_scheduler.scheduler.logging.info", mock_logging_info)
        monkeypatch.setattr("job_scheduler.scheduler.timedelta", mock_timedelta)
        
        # Test with full day names
        mock_job = Mock()
        mock_job.id = 999
        mock_job.frequency = ['Saturday', 'Sunday']
        mock_job.schedule_time = Mock()
        mock_job.schedule_time.hour = 8
        mock_job.schedule_time.minute = 45
        mock_job.start_date = datetime(2024, 1, 1)
        mock_job.end_date = datetime(2024, 1, 2)
        
        # Execute
        JobScheduler.add_job(mock_job)
        
        # Assertions
        expected_days = "sat,sun"
        mock_cron_trigger.assert_called_once_with(
            day_of_week=expected_days,
            hour=8,
            minute=45,
            start_date=datetime(2024, 1, 1),
            end_date=datetime(2024, 1, 2) + timedelta(days=1),
            timezone='US/Eastern'
        )

scheduler_service

import pytest
import json
import requests
from unittest.mock import Mock, patch
from job_scheduler.models.job import JobResponse
from your_module import JobService  # Replace with actual module name


class TestJobService:
    """Test suite for JobService class"""
    
    def setup_method(self):
        """Setup test data for each test method"""
        self.script = "print('Hello World')"
        self.env_name = "test_env"
        self.env_id = "env_123"
        self.execution_endpoint_url = "http://test.example.com/execute"
    
    @patch('requests.post')
    def test_execute_script_success_with_output(self, mock_post):
        """Test successful script execution with output"""
        # Arrange
        mock_response = Mock()
        mock_response.text = json.dumps({"output": "Hello World", "error": ""})
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response
        
        # Act
        result = JobService.execute_script(
            self.script, self.env_name, self.execution_endpoint_url
        )
        
        # Assert
        assert result.status == "success"
        assert result.output == "Hello World"
        assert result.error == ""
        mock_post.assert_called_once_with(
            self.execution_endpoint_url,
            json={"script": self.script, "env_name": self.env_name}
        )
    
    @patch('requests.post')
    def test_execute_script_success_with_error(self, mock_post):
        """Test script execution with error output"""
        # Arrange
        mock_response = Mock()
        mock_response.text = json.dumps({"output": "", "error": "Division by zero"})
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response
        
        # Act
        result = JobService.execute_script(
            self.script, self.env_name, self.execution_endpoint_url
        )
        
        # Assert
        assert result.status == "success"
        assert result.output == ""
        assert result.error == "Division by zero"
    
    @patch('requests.post')
    def test_execute_script_failed_status_empty_output_and_error(self, mock_post):
        """Test failed status when both output and error are empty"""
        # Arrange
        mock_response = Mock()
        mock_response.text = json.dumps({"output": "", "error": ""})
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response
        
        # Act
        result = JobService.execute_script(
            self.script, self.env_name, self.execution_endpoint_url
        )
        
        # Assert
        assert result.status == "failed"
        assert result.output == ""
        assert result.error == ""
    
    @patch('requests.post')
    def test_execute_script_request_exception(self, mock_post):
        """Test handling of requests.RequestException"""
        # Arrange
        mock_post.side_effect = requests.exceptions.RequestException("Connection error")
        
        # Act
        result = JobService.execute_script(
            self.script, self.env_name, self.execution_endpoint_url
        )
        
        # Assert
        assert result.status == "failed"
        assert result.output == ""
        assert result.error == ""
    
    @patch('requests.post')
    def test_execute_script_http_error(self, mock_post):
        """Test handling of HTTP errors (raise_for_status)"""
        # Arrange
        mock_response = Mock()
        mock_response.raise_for_status.side_effect = requests.exceptions.HTTPError("404 Not Found")
        mock_post.return_value = mock_response
        
        # Act
        result = JobService.execute_script(
            self.script, self.env_name, self.execution_endpoint_url
        )
        
        # Assert
        assert result.status == "failed"
        assert result.output == ""
        assert result.error == ""
    
    @patch('requests.post')
    def test_execute_script_json_decode_error(self, mock_post):
        """Test handling of JSON decode errors"""
        # Arrange
        mock_response = Mock()
        mock_response.text = "invalid json"
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response
        
        # Act
        result = JobService.execute_script(
            self.script, self.env_name, self.execution_endpoint_url
        )
        
        # Assert
        assert result.status == "failed"
        assert result.output == ""
        assert result.error == ""
    
    @patch('requests.post')
    def test_execute_script_missing_keys_in_response(self, mock_post):
        """Test handling when response JSON is missing expected keys"""
        # Arrange
        mock_response = Mock()
        mock_response.text = json.dumps({"some_other_key": "value"})
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response
        
        # Act
        result = JobService.execute_script(
            self.script, self.env_name, self.execution_endpoint_url
        )
        
        # Assert
        assert result.status == "failed"  # Both output and error will be None, treated as empty
        assert result.output is None
        assert result.error is None
    
    @patch.object(JobService, 'execute_script')
    def test_send_script_to_jobservice_success(self, mock_execute_script):
        """Test successful send_script_to_jobservice"""
        # Arrange
        expected_response = JobResponse(
            status="success", 
            output="Test output", 
            error=""
        )
        mock_execute_script.return_value = expected_response
        
        # Act
        result = JobService.send_script_to_jobservice(
            self.script, self.env_id, self.execution_endpoint_url
        )
        
        # Assert
        assert result == expected_response
        mock_execute_script.assert_called_once_with(
            self.script, self.env_id, self.execution_endpoint_url
        )
    
    @patch.object(JobService, 'execute_script')
    def test_send_script_to_jobservice_request_exception(self, mock_execute_script):
        """Test send_script_to_jobservice with RequestException"""
        # Arrange
        mock_execute_script.side_effect = requests.exceptions.RequestException("Network error")
        
        # Act & Assert
        with pytest.raises(requests.exceptions.RequestException):
            JobService.send_script_to_jobservice(
                self.script, self.env_id, self.execution_endpoint_url
            )
    
    @patch.object(JobService, 'execute_script')
    def test_send_script_to_jobservice_generic_exception(self, mock_execute_script):
        """Test send_script_to_jobservice with generic Exception"""
        # Arrange
        mock_execute_script.side_effect = Exception("Unexpected error")
        
        # Act & Assert
        with pytest.raises(Exception):
            JobService.send_script_to_jobservice(
                self.script, self.env_id, self.execution_endpoint_url
            )
    
    @patch('requests.post')
    def test_execute_script_with_none_values(self, mock_post):
        """Test execute_script with None values in response"""
        # Arrange
        mock_response = Mock()
        mock_response.text = json.dumps({"output": None, "error": None})
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response
        
        # Act
        result = JobService.execute_script(
            self.script, self.env_name, self.execution_endpoint_url
        )
        
        # Assert
        assert result.status == "failed"  # None values treated as falsy
        assert result.output is None
        assert result.error is None
    
    @patch('requests.post')
    def test_execute_script_partial_success(self, mock_post):
        """Test execute_script with output but no error (partial success)"""
        # Arrange
        mock_response = Mock()
        mock_response.text = json.dumps({"output": "Some output", "error": ""})
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response
        
        # Act
        result = JobService.execute_script(
            self.script, self.env_name, self.execution_endpoint_url
        )
        
        # Assert
        assert result.status == "success"
        assert result.output == "Some output"
        assert result.error == ""
    
    @patch('requests.post')
    def test_execute_script_empty_string_parameters(self, mock_post):
        """Test execute_script with empty string parameters"""
        # Arrange
        mock_response = Mock()
        mock_response.text = json.dumps({"output": "result", "error": ""})
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response
        
        # Act
        result = JobService.execute_script("", "", self.execution_endpoint_url)
        
        # Assert
        assert result.status == "success"
        mock_post.assert_called_once_with(
            self.execution_endpoint_url,
            json={"script": "", "env_name": ""}
        )


# Fixtures for testing
@pytest.fixture
def job_service():
    """Fixture to provide JobService instance"""
    return JobService()


# Integration-style tests
class TestJobServiceIntegration:
    """Integration tests to verify the complete flow"""
    
    @patch('requests.post')
    def test_complete_success_flow(self, mock_post):
        """Test the complete successful execution flow"""
        # Arrange
        mock_response = Mock()
        mock_response.text = json.dumps({
            "output": "Script executed successfully", 
            "error": ""
        })
        mock_response.raise_for_status.return_value = None
        mock_post.return_value = mock_response
        
        script = "print('Integration test')"
        env_id = "integration_env"
        endpoint = "http://integration.test.com/execute"
        
        # Act
        result = JobService.send_script_to_jobservice(script, env_id, endpoint)
        
        # Assert
        assert result.status == "success"
        assert result.output == "Script executed successfully"
        assert result.error == ""
        
        # Verify the underlying call was made correctly
        mock_post.assert_called_once_with(
            endpoint,
            json={"script": script, "env_name": env_id}
        )

lifeservice.test
import pytest
import asyncio
import logging
from unittest.mock import Mock, patch, AsyncMock
from contextlib import asynccontextmanager
from fastapi import FastAPI

# Fixed version of your original code for reference
@asynccontextmanager
async def lifespan(app: FastAPI):
    """Handles startup and shutdown events for the application."""
    logger = logging.getLogger(__name__)
    logger.info("Application startup...")
    
    # Startup
    try:
        from job_scheduler.database import init_db
        init_db()
        logger.info("Database initialized successfully.")
    except Exception as e:
        logger.error(f"Error initializing database: {e}")

    try:
        from job_scheduler.services.job_scheduler import JobScheduler
        JobScheduler.initialize_scheduler()
        JobScheduler.start_scheduler()
        logger.info("APScheduler initialized and started.")
    except Exception as e:
        logger.error(f"Error initializing or starting APScheduler: {e}")
    
    yield
    
    # Shutdown
    logger.info("Application shutdown...")
    try:
        from job_scheduler.services.job_scheduler import JobScheduler
        JobScheduler.shutdown_scheduler()
        logger.info("APScheduler shut down.")
    except Exception as e:
        logger.error(f"Error during APScheduler shutdown: {e}")


class TestLifespan:
    """Test suite for FastAPI lifespan function."""

    @pytest.fixture
    def mock_app(self):
        """Create a mock FastAPI app."""
        return Mock(spec=FastAPI)

    @pytest.fixture
    def mock_logger(self, monkeypatch):
        """Mock the logger."""
        mock_logger = Mock()
        monkeypatch.setattr("logging.getLogger", Mock(return_value=mock_logger))
        return mock_logger

    @pytest.mark.asyncio
    async def test_lifespan_successful_startup_and_shutdown(self, mock_app, mock_logger, monkeypatch):
        """Test successful startup and shutdown without errors."""
        # Mock dependencies
        mock_init_db = Mock()
        mock_job_scheduler = Mock()
        
        # Mock imports
        mock_init_db_module = Mock()
        mock_init_db_module.init_db = mock_init_db
        
        mock_job_scheduler_module = Mock()
        mock_job_scheduler_module.JobScheduler = mock_job_scheduler
        
        def mock_import(name, *args, **kwargs):
            if name == "job_scheduler.database":
                return mock_init_db_module
            elif name == "job_scheduler.services.job_scheduler":
                return mock_job_scheduler_module
            return Mock()
        
        monkeypatch.setattr("builtins.__import__", mock_import)
        
        # Execute lifespan context manager
        async with lifespan(mock_app):
            # Verify startup calls
            mock_init_db.assert_called_once()
            mock_job_scheduler.initialize_scheduler.assert_called_once()
            mock_job_scheduler.start_scheduler.assert_called_once()
        
        # Verify shutdown calls
        mock_job_scheduler.shutdown_scheduler.assert_called_once()
        
        # Verify logging calls
        assert mock_logger.info.call_count == 4
        mock_logger.info.assert_any_call("Application startup...")
        mock_logger.info.assert_any_call("Database initialized successfully.")
        mock_logger.info.assert_any_call("APScheduler initialized and started.")
        mock_logger.info.assert_any_call("Application shutdown...")
        mock_logger.info.assert_any_call("APScheduler shut down.")

    @pytest.mark.asyncio
    async def test_lifespan_database_init_error(self, mock_app, mock_logger, monkeypatch):
        """Test handling of database initialization error."""
        # Mock init_db to raise an exception
        mock_init_db = Mock(side_effect=Exception("Database connection failed"))
        mock_job_scheduler = Mock()
        
        mock_init_db_module = Mock()
        mock_init_db_module.init_db = mock_init_db
        
        mock_job_scheduler_module = Mock()
        mock_job_scheduler_module.JobScheduler = mock_job_scheduler
        
        def mock_import(name, *args, **kwargs):
            if name == "job_scheduler.database":
                return mock_init_db_module
            elif name == "job_scheduler.services.job_scheduler":
                return mock_job_scheduler_module
            return Mock()
        
        monkeypatch.setattr("builtins.__import__", mock_import)
        
        async with lifespan(mock_app):
            # Verify that job scheduler still gets initialized despite DB error
            mock_job_scheduler.initialize_scheduler.assert_called_once()
            mock_job_scheduler.start_scheduler.assert_called_once()
        
        # Verify error was logged
        mock_logger.error.assert_any_call("Error initializing database: Database connection failed")
        
        # Verify shutdown still happens
        mock_job_scheduler.shutdown_scheduler.assert_called_once()

    @pytest.mark.asyncio
    async def test_lifespan_scheduler_init_error(self, mock_app, mock_logger, monkeypatch):
        """Test handling of scheduler initialization error."""
        mock_init_db = Mock()
        mock_job_scheduler = Mock()
        mock_job_scheduler.initialize_scheduler.side_effect = Exception("Scheduler init failed")
        
        mock_init_db_module = Mock()
        mock_init_db_module.init_db = mock_init_db
        
        mock_job_scheduler_module = Mock()
        mock_job_scheduler_module.JobScheduler = mock_job_scheduler
        
        def mock_import(name, *args, **kwargs):
            if name == "job_scheduler.database":
                return mock_init_db_module
            elif name == "job_scheduler.services.job_scheduler":
                return mock_job_scheduler_module
            return Mock()
        
        monkeypatch.setattr("builtins.__import__", mock_import)
        
        async with lifespan(mock_app):
            # Verify database was still initialized
            mock_init_db.assert_called_once()
        
        # Verify error was logged
        mock_logger.error.assert_any_call("Error initializing or starting APScheduler: Scheduler init failed")
        
        # Verify shutdown still attempts to run
        mock_job_scheduler.shutdown_scheduler.assert_called_once()

    @pytest.mark.asyncio
    async def test_lifespan_scheduler_start_error(self, mock_app, mock_logger, monkeypatch):
        """Test handling of scheduler start error."""
        mock_init_db = Mock()
        mock_job_scheduler = Mock()
        mock_job_scheduler.start_scheduler.side_effect = Exception("Scheduler start failed")
        
        mock_init_db_module = Mock()
        mock_init_db_module.init_db = mock_init_db
        
        mock_job_scheduler_module = Mock()
        mock_job_scheduler_module.JobScheduler = mock_job_scheduler
        
        def mock_import(name, *args, **kwargs):
            if name == "job_scheduler.database":
                return mock_init_db_module
            elif name == "job_scheduler.services.job_scheduler":
                return mock_job_scheduler_module
            return Mock()
        
        monkeypatch.setattr("builtins.__import__", mock_import)
        
        async with lifespan(mock_app):
            # Verify both database and scheduler init were called
            mock_init_db.assert_called_once()
            mock_job_scheduler.initialize_scheduler.assert_called_once()
        
        # Verify error was logged
        mock_logger.error.assert_any_call("Error initializing or starting APScheduler: Scheduler start failed")

    @pytest.mark.asyncio
    async def test_lifespan_scheduler_shutdown_error(self, mock_app, mock_logger, monkeypatch):
        """Test handling of scheduler shutdown error."""
        mock_init_db = Mock()
        mock_job_scheduler = Mock()
        mock_job_scheduler.shutdown_scheduler.side_effect = Exception("Scheduler shutdown failed")
        
        mock_init_db_module = Mock()
        mock_init_db_module.init_db = mock_init_db
        
        mock_job_scheduler_module = Mock()
        mock_job_scheduler_module.JobScheduler = mock_job_scheduler
        
        def mock_import(name, *args, **kwargs):
            if name == "job_scheduler.database":
                return mock_init_db_module
            elif name == "job_scheduler.services.job_scheduler":
                return mock_job_scheduler_module
            return Mock()
        
        monkeypatch.setattr("builtins.__import__", mock_import)
        
        async with lifespan(mock_app):
            pass  # Startup completes successfully
        
        # Verify shutdown error was logged
        mock_logger.error.assert_any_call("Error during APScheduler shutdown: Scheduler shutdown failed")

    @pytest.mark.asyncio
    async def test_lifespan_multiple_errors(self, mock_app, mock_logger, monkeypatch):
        """Test handling of multiple errors during startup and shutdown."""
        mock_init_db = Mock(side_effect=Exception("DB error"))
        mock_job_scheduler = Mock()
        mock_job_scheduler.initialize_scheduler.side_effect = Exception("Scheduler error")
        mock_job_scheduler.shutdown_scheduler.side_effect = Exception("Shutdown error")
        
        mock_init_db_module = Mock()
        mock_init_db_module.init_db = mock_init_db
        
        mock_job_scheduler_module = Mock()
        mock_job_scheduler_module.JobScheduler = mock_job_scheduler
        
        def mock_import(name, *args, **kwargs):
            if name == "job_scheduler.database":
                return mock_init_db_module
            elif name == "job_scheduler.services.job_scheduler":
                return mock_job_scheduler_module
            return Mock()
        
        monkeypatch.setattr("builtins.__import__", mock_import)
        
        async with lifespan(mock_app):
            pass
        
        # Verify all errors were logged
        mock_logger.error.assert_any_call("Error initializing database: DB error")
        mock_logger.error.assert_any_call("Error initializing or starting APScheduler: Scheduler error")
        mock_logger.error.assert_any_call("Error during APScheduler shutdown: Shutdown error")

    @pytest.mark.asyncio
    async def test_lifespan_import_errors(self, mock_app, mock_logger, monkeypatch):
        """Test handling of import errors."""
        def mock_import_with_error(name, *args, **kwargs):
            if name == "job_scheduler.database":
                raise ImportError("Cannot import database module")
            elif name == "job_scheduler.services.job_scheduler":
                raise ImportError("Cannot import job scheduler module")
            return Mock()
        
        monkeypatch.setattr("builtins.__import__", mock_import_with_error)
        
        async with lifespan(mock_app):
            pass
        
        # Verify import errors were caught and logged
        assert mock_logger.error.call_count >= 2

    @pytest.mark.asyncio 
    async def test_lifespan_yield_behavior(self, mock_app, mock_logger, monkeypatch):
        """Test that lifespan properly yields control to the application."""
        mock_init_db = Mock()
        mock_job_scheduler = Mock()
        
        mock_init_db_module = Mock()
        mock_init_db_module.init_db = mock_init_db
        
        mock_job_scheduler_module = Mock()
        mock_job_scheduler_module.JobScheduler = mock_job_scheduler
        
        def mock_import(name, *args, **kwargs):
            if name == "job_scheduler.database":
                return mock_init_db_module
            elif name == "job_scheduler.services.job_scheduler":
                return mock_job_scheduler_module
            return Mock()
        
        monkeypatch.setattr("builtins.__import__", mock_import)
        
        startup_completed = False
        shutdown_completed = False
        
        async with lifespan(mock_app) as context:
            # This code runs after startup, before shutdown
            startup_completed = True
            assert context is None  # lifespan doesn't yield a value
            
            # Verify startup has completed
            mock_init_db.assert_called_once()
            mock_job_scheduler.initialize_scheduler.assert_called_once()
            mock_job_scheduler.start_scheduler.assert_called_once()
        
        shutdown_completed = True
        
        # Verify both startup and shutdown completed
        assert startup_completed
        assert shutdown_completed
        mock_job_scheduler.shutdown_scheduler.assert_called_once()


# Additional integration-style test
class TestLifespanIntegration:
    """Integration tests for lifespan with real FastAPI app."""
    
    @pytest.mark.asyncio
    async def test_lifespan_with_fastapi_app(self, monkeypatch):
        """Test lifespan function with actual FastAPI app instance."""
        from fastapi import FastAPI
        
        # Mock the dependencies
        mock_init_db = Mock()
        mock_job_scheduler = Mock()
        
        mock_init_db_module = Mock()
        mock_init_db_module.init_db = mock_init_db
        
        mock_job_scheduler_module = Mock()
        mock_job_scheduler_module.JobScheduler = mock_job_scheduler
        
        def mock_import(name, *args, **kwargs):
            if name == "job_scheduler.database":
                return mock_init_db_module
            elif name == "job_scheduler.services.job_scheduler":
                return mock_job_scheduler_module
            return Mock()
        
        monkeypatch.setattr("builtins.__import__", mock_import)
        
        # Create real FastAPI app with lifespan
        app = FastAPI(lifespan=lifespan)
        
        # Test the lifespan directly
        async with lifespan(app):
            # Application would run here
            assert mock_init_db.called
            assert mock_job_scheduler.initialize_scheduler.called
            assert mock_job_scheduler.start_scheduler.called
        
        # Verify cleanup
        assert mock_job_scheduler.shutdown_scheduler.called


# Conftest.py content for pytest configuration
pytest_configuration = '''
# conftest.py
import pytest
import asyncio

@pytest.fixture(scope="session")
def event_loop():
    """Create an instance of the default event loop for the test session."""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture(autouse=True)
def reset_modules():
    """Reset imported modules between tests to avoid state pollution."""
    import sys
    modules_to_remove = [
        name for name in sys.modules 
        if name.startswith('job_scheduler')
    ]
    for module in modules_to_remove:
        if module in sys.modules:
            del sys.modules[module]
'''



import pytest
from fastapi import HTTPException, status
from fastapi.testclient import TestClient
from fastapi import FastAPI
from unittest.mock import Mock
from sqlalchemy.orm import Session

# Import the router (assuming the corrected import structure)
from job_scheduler.routes.scheduler import router
from job_scheduler.models.job import ScheduleJobRequest, ScheduledJobResponse, JobDetailsResponse
from job_scheduler.database import get_db


# Create test app
app = FastAPI()
app.include_router(router)


@pytest.fixture
def client():
    """Create test client."""
    return TestClient(app)


@pytest.fixture
def mock_db():
    """Create mock database session."""
    return Mock(spec=Session)


@pytest.fixture
def sample_job_request():
    """Sample job request data."""
    return {
        "name": "test_job",
        "description": "Test job description",
        "schedule": "0 0 * * *",  # Daily at midnight
        "command": "echo 'test'",
        "enabled": True
    }


@pytest.fixture
def sample_scheduled_job_response():
    """Sample scheduled job response."""
    return ScheduledJobResponse(
        id=1,
        name="test_job",
        description="Test job description",
        schedule="0 0 * * *",
        command="echo 'test'",
        enabled=True,
        created_at="2024-01-01T00:00:00",
        updated_at="2024-01-01T00:00:00"
    )


@pytest.fixture
def sample_job_details_response():
    """Sample job details response."""
    return JobDetailsResponse(
        id=1,
        name="test_job",
        description="Test job description",
        schedule="0 0 * * *",
        command="echo 'test'",
        enabled=True,
        created_at="2024-01-01T00:00:00",
        updated_at="2024-01-01T00:00:00",
        last_run="2024-01-01T00:00:00",
        next_run="2024-01-02T00:00:00",
        status="active"
    )


class TestScheduleJob:
    """Test cases for schedule_job endpoint."""
    
    def test_schedule_job_success(self, client, mock_db, sample_job_request, 
                                sample_scheduled_job_response, monkeypatch):
        """Test successful job scheduling."""
        # Mock the database dependency
        monkeypatch.setattr("job_scheduler.routes.scheduler.get_db", 
                          lambda: mock_db)
        
        # Mock the service method
        mock_service = Mock()
        mock_service.schedule_new_job.return_value = sample_scheduled_job_response
        monkeypatch.setattr("job_scheduler.routes.scheduler.db_service", 
                          mock_service)
        
        # Override dependency for this test
        app.dependency_overrides[get_db] = lambda: mock_db
        
        response = client.post("/scheduleJob", json=sample_job_request)
        
        assert response.status_code == 200
        assert response.json()["id"] == 1
        assert response.json()["name"] == "test_job"
        
        # Verify service was called with correct parameters
        mock_service.schedule_new_job.assert_called_once()
        call_args = mock_service.schedule_new_job.call_args
        assert call_args[0][1] == mock_db  # db parameter
        
        # Clean up
        app.dependency_overrides.clear()
    
    def test_schedule_job_invalid_data(self, client, mock_db, monkeypatch):
        """Test job scheduling with invalid data."""
        # Mock the database dependency
        app.dependency_overrides[get_db] = lambda: mock_db
        
        # Mock service to raise exception
        mock_service = Mock()
        mock_service.schedule_new_job.side_effect = HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid job data"
        )
        monkeypatch.setattr("job_scheduler.routes.scheduler.db_service", 
                          mock_service)
        
        invalid_request = {"invalid": "data"}
        response = client.post("/scheduleJob", json=invalid_request)
        
        # Should return 422 for validation error or propagate HTTPException
        assert response.status_code in [400, 422]
        
        # Clean up
        app.dependency_overrides.clear()
    
    def test_schedule_job_service_error(self, client, mock_db, sample_job_request, 
                                      monkeypatch):
        """Test job scheduling when service raises an error."""
        # Mock the database dependency
        app.dependency_overrides[get_db] = lambda: mock_db
        
        # Mock service to raise exception
        mock_service = Mock()
        mock_service.schedule_new_job.side_effect = HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Database error"
        )
        monkeypatch.setattr("job_scheduler.routes.scheduler.db_service", 
                          mock_service)
        
        response = client.post("/scheduleJob", json=sample_job_request)
        
        assert response.status_code == 500
        
        # Clean up
        app.dependency_overrides.clear()


class TestGetScheduledJobs:
    """Test cases for get_scheduled_jobs endpoint."""
    
    def test_get_scheduled_jobs_success(self, client, mock_db, 
                                      sample_scheduled_job_response, monkeypatch):
        """Test successful retrieval of scheduled jobs."""
        # Mock the database dependency
        app.dependency_overrides[get_db] = lambda: mock_db
        
        # Mock the service method
        mock_service = Mock()
        mock_service.fetch_scheduled_jobs.return_value = [sample_scheduled_job_response]
        monkeypatch.setattr("job_scheduler.routes.scheduler.db_service", 
                          mock_service)
        
        response = client.get("/getScheduledJobs")
        
        assert response.status_code == 200
        assert len(response.json()) == 1
        assert response.json()[0]["id"] == 1
        assert response.json()[0]["name"] == "test_job"
        
        # Verify service was called with correct parameters
        mock_service.fetch_scheduled_jobs.assert_called_once_with(mock_db)
        
        # Clean up
        app.dependency_overrides.clear()
    
    def test_get_scheduled_jobs_empty_list(self, client, mock_db, monkeypatch):
        """Test retrieval when no jobs are scheduled."""
        # Mock the database dependency
        app.dependency_overrides[get_db] = lambda: mock_db
        
        # Mock service to return empty list
        mock_service = Mock()
        mock_service.fetch_scheduled_jobs.return_value = []
        monkeypatch.setattr("job_scheduler.routes.scheduler.db_service", 
                          mock_service)
        
        response = client.get("/getScheduledJobs")
        
        assert response.status_code == 200
        assert response.json() == []
        
        # Clean up
        app.dependency_overrides.clear()
    
    def test_get_scheduled_jobs_service_error(self, client, mock_db, monkeypatch):
        """Test get scheduled jobs when service raises an error."""
        # Mock the database dependency
        app.dependency_overrides[get_db] = lambda: mock_db
        
        # Mock service to raise exception
        mock_service = Mock()
        mock_service.fetch_scheduled_jobs.side_effect = HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Database connection failed"
        )
        monkeypatch.setattr("job_scheduler.routes.scheduler.db_service", 
                          mock_service)
        
        response = client.get("/getScheduledJobs")
        
        assert response.status_code == 500
        
        # Clean up
        app.dependency_overrides.clear()


class TestGetJobDetails:
    """Test cases for get_job_details endpoint."""
    
    def test_get_job_details_success(self, client, mock_db, 
                                   sample_job_details_response, monkeypatch):
        """Test successful retrieval of job details."""
        # Mock the database dependency
        app.dependency_overrides[get_db] = lambda: mock_db
        
        # Mock the service method
        mock_service = Mock()
        mock_service.fetch_job_details.return_value = sample_job_details_response
        monkeypatch.setattr("job_scheduler.routes.scheduler.db_service", 
                          mock_service)
        
        job_id = 1
        response = client.get(f"/schedulerjobs/{job_id}")
        
        assert response.status_code == 200
        assert response.json()["id"] == 1
        assert response.json()["name"] == "test_job"
        assert response.json()["status"] == "active"
        
        # Verify service was called with correct parameters
        mock_service.fetch_job_details.assert_called_once_with(job_id, mock_db)
        
        # Clean up
        app.dependency_overrides.clear()
    
    def test_get_job_details_not_found(self, client, mock_db, monkeypatch):
        """Test job details retrieval for non-existent job."""
        # Mock the database dependency
        app.dependency_overrides[get_db] = lambda: mock_db
        
        # Mock service to raise not found exception
        mock_service = Mock()
        mock_service.fetch_job_details.side_effect = HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Job not found"
        )
        monkeypatch.setattr("job_scheduler.routes.scheduler.db_service", 
                          mock_service)
        
        job_id = 999
        response = client.get(f"/schedulerjobs/{job_id}")
        
        assert response.status_code == 404
        
        # Clean up
        app.dependency_overrides.clear()
    
    def test_get_job_details_invalid_id(self, client, mock_db, monkeypatch):
        """Test job details retrieval with invalid job ID."""
        # Mock the database dependency
        app.dependency_overrides[get_db] = lambda: mock_db
        
        # Mock the service method (shouldn't be called due to path validation)
        mock_service = Mock()
        monkeypatch.setattr("job_scheduler.routes.scheduler.db_service", 
                          mock_service)
        
        response = client.get("/schedulerjobs/invalid_id")
        
        assert response.status_code == 422  # Validation error
        
        # Service should not be called due to path parameter validation
        mock_service.fetch_job_details.assert_not_called()
        
        # Clean up
        app.dependency_overrides.clear()
    
    def test_get_job_details_service_error(self, client, mock_db, monkeypatch):
        """Test get job details when service raises an error."""
        # Mock the database dependency
        app.dependency_overrides[get_db] = lambda: mock_db
        
        # Mock service to raise exception
        mock_service = Mock()
        mock_service.fetch_job_details.side_effect = HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Database error"
        )
        monkeypatch.setattr("job_scheduler.routes.scheduler.db_service", 
                          mock_service)
        
        job_id = 1
        response = client.get(f"/schedulerjobs/{job_id}")
        
        assert response.status_code == 500
        
        # Clean up
        app.dependency_overrides.clear()


class TestDependencyInjection:
    """Test cases for dependency injection."""
    
    def test_database_dependency_called(self, client, monkeypatch):
        """Test that database dependency is properly called."""
        mock_db = Mock(spec=Session)
        mock_get_db = Mock(return_value=mock_db)
        
        # Mock the service
        mock_service = Mock()
        mock_service.fetch_scheduled_jobs.return_value = []
        monkeypatch.setattr("job_scheduler.routes.scheduler.db_service", 
                          mock_service)
        
        # Override the dependency
        app.dependency_overrides[get_db] = mock_get_db
        
        response = client.get("/getScheduledJobs")
        
        assert response.status_code == 200
        # Verify the service was called with the mocked db
        mock_service.fetch_scheduled_jobs.assert_called_once_with(mock_db)
        
        # Clean up
        app.dependency_overrides.clear()


# Integration-style tests that test the router more holistically
class TestRouterIntegration:
    """Integration tests for the router."""
    
    def test_all_endpoints_exist(self, client):
        """Test that all expected endpoints exist and return appropriate status codes."""
        # Test POST endpoint exists (even if it fails due to missing data)
        response = client.post("/scheduleJob", json={})
        assert response.status_code in [400, 422, 500]  # Should not be 404
        
        # Test GET endpoints exist
        response = client.get("/getScheduledJobs")
        assert response.status_code != 404
        
        response = client.get("/schedulerjobs/1")
        assert response.status_code != 404
    
    def test_router_tags(self, client):
        """Test that router has correct tags."""
        # This would be tested by examining the OpenAPI schema
        # For now, we'll just verify the router is included
        assert router.tags == ["scheduler"]


# Run with: pytest test_scheduler.py -v --cov=job_scheduler.routes.scheduler --cov-report=html

